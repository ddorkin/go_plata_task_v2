package main

import (
	"context"
	"fmt"
	"net/http"
	"os"
	"os/signal"
	"syscall"

	"go_plata_task_v2/internal/config"
	"go_plata_task_v2/internal/database"
	"go_plata_task_v2/internal/external"
	"go_plata_task_v2/internal/handlers"
	"go_plata_task_v2/internal/logger"
	"go_plata_task_v2/internal/middleware"
	"go_plata_task_v2/internal/worker"

	_ "go_plata_task_v2/docs" // docs is generated by Swag CLI, you have to import it.

	"github.com/gorilla/mux"
	httpSwagger "github.com/swaggo/http-swagger"
)

// @title Currency Quote Service API
// @version 1.0
// @description Сервис котировок валютных курсов с асинхронным обновлением

// @host localhost:8080
// @BasePath /api/v1

// @schemes http https
func main() {
	// Загружаем конфигурацию
	cfg := config.Load()

	// Инициализируем логгер
	log := logger.New(cfg.Logging.Level)

	log.WithFields(map[string]interface{}{
		"host":      cfg.Server.Host,
		"port":      cfg.Server.Port,
		"log_level": cfg.Logging.Level,
		"db_host":   cfg.Database.Host,
		"db_name":   cfg.Database.DBName,
	}).Info("Starting Currency Quote Service")

	// Инициализируем базу данных
	db, err := database.New(&cfg.Database, log.Logger)
	if err != nil {
		log.WithError(err).Fatal("Failed to initialize database")
	}
	defer db.Close()

	// Инициализируем внешний API клиент
	externalAPI := external.New(&cfg.External, cfg.App.SupportedCurrencies, log.Logger)

	// Создаем фоновый воркер
	quoteWorker := worker.New(db, externalAPI, log.Logger, cfg.Worker.Interval)

	// Создаем контекст для graceful shutdown
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	// Запускаем фоновый воркер
	quoteWorker.Start(ctx)
	defer quoteWorker.Stop()

	// Создаем роутер
	router := mux.NewRouter()

	// Применяем middleware
	router.Use(middleware.RecoveryMiddleware(log.Logger))
	router.Use(middleware.LoggingMiddleware(log.Logger))
	router.Use(middleware.CORSMiddleware()) // добавляю CORS middleware (необязательно, но пусть будет сразу)

	// Создаем API v1 роутер (версию добавляю на всякий случай)
	apiV1 := router.PathPrefix("/api/v1").Subrouter()

	// Создаем обработчики и регистрируем маршруты
	handler := handlers.New(db, log.Logger, cfg.App.SupportedCurrencies)
	handler.RegisterRoutes(apiV1)

	// Добавляем Swagger документацию
	router.PathPrefix("/swagger/").Handler(httpSwagger.Handler(
		httpSwagger.URL("http://localhost:8080/swagger/doc.json"),
	))

	// Маршрут для swagger.json
	router.Path("/swagger/doc.json").HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		http.ServeFile(w, r, "./docs/swagger.json")
	})

	// Создаем HTTP сервер
	server := &http.Server{
		Addr:         fmt.Sprintf("%s:%s", cfg.Server.Host, cfg.Server.Port),
		Handler:      router,
		ReadTimeout:  cfg.Server.ReadTimeout,
		WriteTimeout: cfg.Server.WriteTimeout,
		IdleTimeout:  cfg.Server.IdleTimeout,
	}

	// Запускаем сервер в горутине
	go func() {
		log.WithField("address", server.Addr).Info("Server started")
		if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			log.WithError(err).Fatal("Failed to start server")
		}
	}()

	// Выводим информацию о доступных маршрутах
	printRoutes(log)

	// Ожидаем сигнал для graceful shutdown
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	<-quit

	log.Info("Shutting down server...")

	// Останавливаем воркер
	quoteWorker.Stop()

	// Создаем контекст с таймаутом для graceful shutdown
	shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), cfg.App.ShutdownTimeout)
	defer shutdownCancel()

	// Останавливаем сервер
	if err := server.Shutdown(shutdownCtx); err != nil {
		log.WithError(err).Error("Server forced to shutdown")
		os.Exit(1)
	}

	log.Info("Server exited")
}

func printRoutes(log *logger.Logger) {
	routes := []struct {
		Path   string
		Method string
		Desc   string
	}{
		{"/api/v1/quotes/update", "POST", "Обновить котировку валютной пары"},
		{"/api/v1/quotes/{id}", "GET", "Получить котировку по ID запроса"},
		{"/api/v1/quotes/latest", "GET", "Получить последнюю котировку валютной пары"},
		{"/api/v1/health", "GET", "Health check"},
		{"/swagger/", "GET", "Swagger документация"},
	}

	log.Info("Available routes:")
	for _, route := range routes {
		log.WithFields(map[string]interface{}{
			"path":   route.Path,
			"method": route.Method,
			"desc":   route.Desc,
		}).Info("Route")
	}
}
